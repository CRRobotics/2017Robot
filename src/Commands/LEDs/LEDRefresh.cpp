// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "LEDRefresh.h"
#include "../../Subsystems/LEDs.h"
#define DESIRED_INTERVAL 5000
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
long LEDRefresh::mode_end_time;
LEDs::LEDMode LEDRefresh::defaultMode;

LEDRefresh::LEDRefresh(): Command() {
	Requires(Robot::leds.get());
	SmartDashboard::PutNumber("led_interval_ms", 0.0);
	defaultMode = LEDs::LEDMode::PATRIOTIC;
	last_time = 0;
}


// Called just before this Command runs the first time
void LEDRefresh::Initialize() {
	for(int i = 0; i < 88; i++){
		//(*Robot::leds->colors)[i].r = 0x10;
	}
	last_time = std::chrono::system_clock::now().time_since_epoch().count() * 1000 * std::chrono::system_clock::period::num / std::chrono::system_clock::period::den;
	mode_end_time = -1;
}

// Called repeatedly when this Command is scheduled to run
void LEDRefresh::Execute() {
	long current_time = std::chrono::system_clock::now().time_since_epoch().count() * 1000 * std::chrono::system_clock::period::num / std::chrono::system_clock::period::den;
	if (current_time - last_time > Robot::leds->cycle_time)
	{
		Robot::leds->Refresh();
		last_time = current_time;
	}
	if (mode_end_time != -1 && current_time - mode_end_time > 0)
	{
		Robot::leds->ChangeMode(defaultMode);
		mode_end_time = -1;
	}
}

void LEDRefresh::ExecuteCopy()
{
	long current_time = std::chrono::system_clock::now().time_since_epoch().count() * 1000 * std::chrono::system_clock::period::num / std::chrono::system_clock::period::den;
		if (current_time - last_time > Robot::leds->cycle_time)
		{
			Robot::leds->Refresh();
			last_time = current_time;
		}
		if (mode_end_time != -1 && current_time - mode_end_time > 0)
		{
			Robot::leds->ChangeMode(defaultMode);
			mode_end_time = -1;
		}
}

// Make this return true when this Command no longer needs to run execute()
bool LEDRefresh::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void LEDRefresh::End() {
	SmartDashboard::PutBoolean("LED RUNNING", false);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void LEDRefresh::Interrupted() {
	SmartDashboard::PutBoolean("LED RUNNING", false);
}

void LEDRefresh::SetMode(LEDs::LEDMode mode, long duration)
{
	Robot::leds->ChangeMode(mode);
	long current_time = std::chrono::system_clock::now().time_since_epoch().count() * 1000 * std::chrono::system_clock::period::num / std::chrono::system_clock::period::den;
	mode_end_time = current_time + duration;
}
